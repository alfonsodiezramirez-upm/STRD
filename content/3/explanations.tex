\begin{itemize}
  \item En los códigos \ref{lst:speedtask} y \ref{lst:lightstask}, el mapeo se realiza con valores
        de entrada $\left[0, 255\right]$ porque el ADC de la placa
        es de 8 bits, por lo que su resolución máxima es 255.
  \item En diversos códigos (como \ref{lst:distancetask} o \ref{lst:braketask}) se
        utilizan eventos para la sincronización de tareas entre sí. Los eventos
        aparecen en la documentación estándar de FreeRTOS y constituyen un mecanismo
        muy sencillo y eficiente que respeta el tiempo real para bloquear y desbloquear
        tareas sin necesidad de programar la lógica subyacente. Un evento, en esencia,
        se conforma de $1 \dots n$ procesos que esperan y, en principio, un único proceso
        $k$ que ``produce'' el evento. En ese instante, aquellas tareas que estaban
        esperando al evento se desbloquean y prosiguen con su ejecución; mientras tanto,
        el proceso $k$ reiniciaría el evento de forma que nuevas tareas pueden esperar
        a que se produzca.

        De esta manera, una tarea esporádica estaría esperando a que un evento se
        produzca y existiría una tarea periódica activadora la cual indicaría
        mediante dicho evento a la tarea esporádica que se tiene que ejecutar.
  \item En el código \ref{lst:wheel-task} se esperan 13 iteraciones que equivalen a un
        tiempo de $\numprint[s]{5.2}$ (en lugar de los $\numprint[s]{5}$ pedidos). Esto
        es debido a que el periodo no es múltiplo, por lo que se comete un error
        ``a la alta'' en lugar de ``a la baja''.
  \item El pitido no se ha implementado a nivel de código ya que no venía especificado
        en los distintos diagramas a qué pin habría que conectarlo ni la lógica de
        control.
  \item En el código \ref{lst:canbustasks} se han implementado dos tareas esporádicas
        porque el CANBus recibe mensajes desde una rutina de interrupción. Como se quieren
        actualizar variables las cuales utilizan un \texttt{lock} internamente, se
        deriva su gestión a un par de tareas esporádicas cuya única finalidad es la
        de actualizar el valor de los objetos protegidos.
\end{itemize}